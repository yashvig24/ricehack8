'use strict';

var _fromCodePoint = require('babel-runtime/core-js/string/from-code-point');

var _fromCodePoint2 = _interopRequireDefault(_fromCodePoint);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emptyArray = (0, _freeze2.default)([]);
var emptyObject = (0, _freeze2.default)((0, _create2.default)(null));

var namedEntities = (0, _freeze2.default)({
  '&amp;': '&',
  '&apos;': "'",
  '&gt;': '>',
  '&lt;': '<',
  '&quot;': '"'
});

var NODE_TYPE_CDATA = 'cdata';
var NODE_TYPE_COMMENT = 'comment';
var NODE_TYPE_DOCUMENT = 'document';
var NODE_TYPE_ELEMENT = 'element';
var NODE_TYPE_TEXT = 'text';

var Syntax = void 0;

module.exports = function parseXml(xml) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyObject;

  if (Syntax === void 0) {
    // Lazy require to defer regex parsing until first use.
    Syntax = require('./lib/syntax');
  }

  if (xml[0] === '\uFEFF') {
    // Strip byte order mark.
    xml = xml.slice(1);
  }

  xml = xml.replace(/\r\n/g, '\n'); // Normalize CRLF to LF.

  var doc = {
    type: NODE_TYPE_DOCUMENT,
    children: [],
    parent: null,
    toJSON: nodeToJson
  };

  var state = {
    length: xml.length,
    options: options,
    parent: doc,
    pos: 0,
    prevPos: 0,
    slice: null,
    xml: xml
  };

  state.replaceReference = replaceReference.bind(state);

  consumeProlog(state);

  if (!consumeElement(state)) {
    error(state, 'Root element is missing or invalid');
  }

  while (consumeMisc(state)) {}

  if (!isEof(state)) {
    error(state, 'Extra content at the end of the document');
  }

  return doc;
};

// -- Private Functions --------------------------------------------------------
function addNode(state, node) {
  node.parent = state.parent;
  node.toJSON = nodeToJson;

  state.parent.children.push(node);
}

function addText(state, text) {
  var children = state.parent.children;

  var prevNode = children[children.length - 1];

  if (prevNode !== void 0 && prevNode.type === NODE_TYPE_TEXT) {
    // The previous node is a text node, so we can append to it and avoid
    // creating another node.
    prevNode.text += text;
  } else {
    addNode(state, {
      type: NODE_TYPE_TEXT,
      text: text
    });
  }
}

// Each `consume*` function takes the current state as an argument and returns
// `true` if `state.pos` was advanced (meaning some XML was consumed) or `false`
// if nothing was consumed.

function consumeCDSect(state) {
  var _scan = scan(state, Syntax.Anchored.CDSect),
      match = _scan[0],
      text = _scan[1];

  if (match === void 0) {
    return false;
  }

  if (state.options.preserveCdata) {
    addNode(state, {
      type: NODE_TYPE_CDATA,
      text: text
    });
  } else {
    addText(state, text);
  }

  return true;
}

function consumeCharData(state) {
  var _scan2 = scan(state, Syntax.Anchored.CharData),
      text = _scan2[0];

  if (text === void 0) {
    return false;
  }

  var cdataCloseIndex = text.indexOf(']]>');

  if (cdataCloseIndex !== -1) {
    state.pos = state.prevPos + cdataCloseIndex;
    error(state, 'Element content may not contain the CDATA section close delimiter `]]>`');
  }

  // Note: XML 1.0 5th ed. says `CharData` is "any string of characters which
  // does not contain the start-delimiter of any markup and does not include the
  // CDATA-section-close delimiter", but the conformance test suite and
  // well-established parsers like libxml seem to restrict `CharData` to
  // characters that match the `Char` symbol, so that's what I've done here.
  if (!Syntax.CharOnly.test(text)) {
    state.pos = state.prevPos + text.search(new RegExp('(?!' + Syntax.Char.source + ')'));
    error(state, 'Element content contains an invalid character');
  }

  addText(state, text);
  return true;
}

function consumeComment(state) {
  var _scan3 = scan(state, Syntax.Anchored.Comment),
      content = _scan3[1];

  if (content === void 0) {
    return false;
  }

  if (state.options.preserveComments) {
    addNode(state, {
      type: NODE_TYPE_COMMENT,
      content: content.trim()
    });
  }

  return true;
}

function consumeDoctypeDecl(state) {
  return scan(state, Syntax.Anchored.doctypedecl).length > 0;
}

function consumeElement(state) {
  var _scan4 = scan(state, Syntax.Anchored.EmptyElemTag),
      tag = _scan4[0],
      name = _scan4[1],
      attrs = _scan4[2];

  var isEmpty = tag !== void 0;

  if (!isEmpty) {
    var _scan5 = scan(state, Syntax.Anchored.STag);

    tag = _scan5[0];
    name = _scan5[1];
    attrs = _scan5[2];


    if (tag === void 0) {
      return false;
    }
  }

  var parent = state.parent;

  var parsedAttrs = parseAttrs(state, attrs);

  var node = {
    type: NODE_TYPE_ELEMENT,
    name: name,
    attributes: parsedAttrs,
    children: []
  };

  var xmlSpace = parsedAttrs['xml:space'];

  if (xmlSpace === 'preserve' || xmlSpace !== 'default' && parent.preserveWhitespace) {

    node.preserveWhitespace = true;
  }

  if (!isEmpty) {
    state.parent = node;

    consumeCharData(state);

    while (consumeElement(state) || consumeReference(state) || consumeCDSect(state) || consumePI(state) || consumeComment(state)) {
      consumeCharData(state);
    }

    var _scan6 = scan(state, Syntax.Anchored.ETag),
        endName = _scan6[1];

    if (endName !== name) {
      state.pos = state.prevPos;
      error(state, 'Missing end tag for element ' + name);
    }

    state.parent = parent;
  }

  addNode(state, node);
  return true;
}

function consumeMisc(state) {
  return consumeComment(state) || consumePI(state) || consumeWhitespace(state);
}

function consumePI(state) {
  var _scan7 = scan(state, Syntax.Anchored.PI),
      match = _scan7[0],
      target = _scan7[1];

  if (match === void 0) {
    return false;
  }

  if (target.toLowerCase() === 'xml') {
    state.pos = state.prevPos;
    error(state, 'XML declaration is only allowed at the start of the document');
  }

  return true;
}

function consumeProlog(state) {
  var pos = state.pos;


  scan(state, Syntax.Anchored.XMLDecl);

  while (consumeMisc(state)) {}

  if (consumeDoctypeDecl(state)) {
    while (consumeMisc(state)) {}
  }

  return state.pos > pos;
}

function consumeReference(state) {
  var _scan8 = scan(state, Syntax.Anchored.Reference),
      ref = _scan8[0];

  if (ref === void 0) {
    return false;
  }

  addText(state, state.replaceReference(ref));
  return true;
}

function consumeWhitespace(state) {
  return scan(state, Syntax.Anchored.S).length > 0;
}

function error(state, message) {
  var pos = state.pos,
      xml = state.xml;

  var column = 1;
  var excerpt = '';
  var line = 1;

  // Find the line and column where the error occurred.
  for (var i = 0; i < pos; ++i) {
    var char = xml[i];

    if (char === '\n') {
      column = 1;
      excerpt = '';
      line += 1;
    } else {
      column += 1;
      excerpt += char;
    }
  }

  var eol = xml.indexOf('\n', pos);

  excerpt += eol === -1 ? xml.slice(pos) : xml.slice(pos, eol);

  var excerptStart = 0;

  // Keep the excerpt below 50 chars, but always keep the error position in
  // view.
  if (excerpt.length > 50) {
    if (column < 40) {
      excerpt = excerpt.slice(0, 50);
    } else {
      excerptStart = column - 20;
      excerpt = excerpt.slice(excerptStart, column + 30);
    }
  }

  var err = new Error(message + ' (line ' + line + ', column ' + column + ')\n' + ('  ' + excerpt + '\n') + ' '.repeat(column - excerptStart + 1) + '^\n');

  err.column = column;
  err.excerpt = excerpt;
  err.line = line;
  err.pos = pos;

  throw err;
}

function isEof(state) {
  return state.pos >= state.length - 1;
}

function nodeToJson() {
  var json = (0, _assign2.default)((0, _create2.default)(null), this);
  delete json.parent;
  return json;
}

function normalizeAttrValue(state, value) {
  return value.replace(Syntax.Global.Reference, state.replaceReference).replace(Syntax.Global.S, ' ').trim();
}

function parseAttrs(state, attrs) {
  var parsedAttrs = (0, _create2.default)(null);

  if (!attrs) {
    return parsedAttrs;
  }

  var attrPairs = attrs.match(Syntax.Global.Attribute).sort();

  for (var i = 0, len = attrPairs.length; i < len; ++i) {
    var attrPair = attrPairs[i];
    var eqMatch = attrPair.match(Syntax.Eq);
    var name = attrPair.slice(0, eqMatch.index);
    var value = attrPair.slice(eqMatch.index + eqMatch[0].length);

    if (name in parsedAttrs) {
      state.pos = state.prevPos;
      error(state, 'Attribute `' + name + '` redefined');
    }

    value = normalizeAttrValue(state, value.slice(1, -1));

    if (name === 'xml:space') {
      if (value !== 'default' && value !== 'preserve') {
        state.pos = state.prevPos;
        error(state, 'Value of the `xml:space` attribute must be "default" or "preserve"');
      }
    }

    parsedAttrs[name] = value;
  }

  return parsedAttrs;
}

function replaceReference(ref) {
  var state = this;

  if (ref[1] === '#') {
    // This is a character entity.
    var codePoint = void 0;

    if (ref[2] === 'x') {
      codePoint = parseInt(ref.slice(3, -1), 16);
    } else {
      codePoint = parseInt(ref.slice(2, -1), 10);
    }

    if (isNaN(codePoint)) {
      state.pos = state.prevPos;
      error(state, 'Invalid character entity `' + ref + '`');
    }

    var char = (0, _fromCodePoint2.default)(codePoint);

    if (!Syntax.Char.test(char)) {
      state.pos = state.prevPos;
      error(state, 'Invalid character entity `' + ref + '`');
    }

    return char;
  }

  // This is a named entity.
  var value = namedEntities[ref];

  if (value !== void 0) {
    return value;
  }

  if (state.options.resolveUndefinedEntity) {
    var resolvedValue = state.options.resolveUndefinedEntity(ref);

    if (resolvedValue !== null && resolvedValue !== void 0) {
      return resolvedValue;
    }
  }

  if (state.options.ignoreUndefinedEntities) {
    return ref;
  }

  state.pos = state.prevPos;
  error(state, 'Named entity isn\'t defined: `' + ref + '`');
}

function scan(state, regex) {
  var pos = state.pos,
      slice = state.slice,
      xml = state.xml;


  if (slice === null) {
    if (pos > 0) {
      slice = xml.slice(pos);
      state.slice = slice;
    } else {
      slice = xml;
    }
  }

  var matches = slice.match(regex);

  if (matches === null) {
    return emptyArray;
  }

  state.prevPos = state.pos;
  state.pos += matches[0].length;
  state.slice = null;

  return matches;
}